#!/bin/sh
#
# git-hyperfine: thing wrapper around hyperfine(1). See --help output
# below.

debug=
debug() {
	if test -n "$debug"
	then
		if test $# -gt 0
		then
			prefix=$1
			shift
			printf "debug: $prefix: %s\n" $@
		fi
		return 0
	fi
	return 1
}

# Out option variables
trace=
dry_run=
worktree_list=
worktree_xargs=

# "Our" option variables
setup=
prepare=
cleanup=
command=
command_name=

# "Our' options variables, intecepted (TODO)
help=
version=

# Pass-through to hyperfine(1)
hyperfine_opt=
hyperfine_output_opt=

# Pass-through to hyperfine(1), but validate
saw_rev=

while test $# -gt 0
do
	#debug "getopt: processing" $1
	case "$1" in
	# git-hyperfine's own options
	--ghf-debug)
		debug=t
		;;
	--ghf-dry-run)
		dry_run=t
		;;
	--ghf-trace)
		trace=t
		set -x
		;;
	--ghf-worktree-xargs)
		worktree_xargs=t
		shift
		break
		;;
	--ghf-worktree-list)
		worktree_list=t
		shift
		break
		;;
	# I need to explicitly intercept these..
	-s|--setup)
		setup=$2
		shift
		;;
	-p|-prepare)
		prepare=$2
		shift
		;;
	-c|--cleanup)
		cleanup=$2
		shift
		;;
	-n|--command-name)
		command_name=$2
		shift
		;;

	# ... but not really these. TODO: Better way to do passthrough
	# "and" understand <command> than to re-parse every option it
	# understands?
	#
	# Probably not, I'll need to know if -L <x> <y> has <y> as a
	# <command> or argument for -L.
	-P|--parameter-scan)
		# Options for hyperfine(1) with three params
		hyperfine_opt="${hyperfine_opt:+$hyperfine_opt }$1 $2 $3 #4"
		shift 3
		;;
	# Options for hyperfine(1) with two params
	-L|--parameter-list)
		if test "$2" = "rev"
		then
			saw_rev=t
		fi
		hyperfine_opt="${hyperfine_opt:+$hyperfine_opt }$1 $2 $3"
		shift 2
		;;
	# Options for hyperfine(1) with one param.
	-w|--warmup| \
	-m|--min-runs| \
	-M|--max-runs| \
	-r|--runs| \
	--style| \
	-D|--parameter-step-size| \
	-S|--shell| \
	-u|--time-unit| \
	--export-asciidoc| \
	--export-csv| \
	--export-markdown| \
	--export-json)
		hyperfine_opt="${hyperfine_opt:+$hyperfine_opt }$1 $2"
		shift
		;;
	# Options for hyperfine(1) without params
	-i|--ignore-failure| \
	--show-output)
		hyperfine_opt="${hyperfine_opt:+$hyperfine_opt }$1"
		;;
	# Output options for hyperfine(1) without params
	-h|--help)
		help=t
		hyperfine_output_opt="${hyperfine_output_opt:+$hyperfine_output_opt }$1"
		;;
	-v|--version)
		version=t
		hyperfine_output_opt="${hyperfine_output_opt:+$hyperfine_output_opt }$1"
		;;
	*)
		# Intercept hyperfine(1) <command>
		command="${command:+$command }$1"
		;;
	esac
	shift
done

## Options debug
debug "getopt: setup" $setup
debug "getopt: prepare" $prepare
debug "getopt: cleanup" $cleanup
debug "getopt: hyperfine opts" $hyperfine_opt
debug "getopt: hyperfine command" $command
debug "getopt: hyperfine command_name" $command_name

## --help output specific to git-hyperfine
if test -n "$help"
then
	cat <<-\EOF
git-hyperfine(1)
================

NAME
----
git-hyperfine(1) - wrapper around man:hyperfine[1], intercepts -L '<rev>', benchmarks git revisions

SYNOPSIS
--------

Instead of:

----
hyperfine [<hyperfine-options>]
----

Do:

----
git hyperfine -L rev <git-revisions> [<hyperfine-options>]
----

DESCRIPTION
-----------

This is a wrapper around man:hyperfine[1] which intercepts '-L rev
<git-revisions>' and sets up a git-worktree(1) for each one.

It needs the --setup option from
https://github.com/sharkdp/hyperfine/pull/448, and can benefit from
'-r 1' as well: https://github.com/sharkdp/hyperfine/pull/447

To test say a <git-revisions> of 'HEAD~1,HEAD~0' well resolve those
comma-delimited revisions in the current working directory (which is
assumed to be a git repository, or we'll die).

We'll then expect a 'hyperfine.run-dir' in your git-config(1) of
e.g. (we'll 'eval' it, so you can use an env variable name):

----
[hyperfine]
run-dir = $XDG_RUNTIME_DIR/git-perf
----

Which, on e.g. modern systemd-using system will resolve to a ramdisk
directory such as '/run/user/1001/git-perf'. We'll then create (with
'git worktree add') both of:

----
/run/user/1001/git-perf/HEAD~0
/run/user/1001/git-perf/HEAD~1
----

Note that we use those literal names, i.e. 'HEAD~0', not whatever 'git
rev-parse HEAD~0'. This is so that we won't create an arbitrary number
of directories. We'll expect that you can re-use them if you keep
testing the last N revisions.

OPTIONS
-------

All options that 'git-hyperfine' interprets are prefixed with
'--ghf-'. Any other option is passed through to
man:hyperfine[1]. We'll change some of them as noted in
<<ALTOPT,ALTERED OPTIONS>>.

--ghf-debug::
	Emit debugging messages about what we're doing internally.

--ghf-trace::
	Instrument generated code with "set -x". For use with
	man:git-hyperfine[1]'s '--show-output'.

--ghf-dry-run::
	Don't run the man:git-hyperfine[1] command, show what would
	have been run.

--ghf-worktree-list::
	A convenience wrapper, runs man:git-worktree[1] with 'list
	--porcelain' and emits only those paths configured under our
	'hyperfine-run-dir' prefix. Useful for e.g.:
+
----
git hyperfine --ghf-worktree-list | xargs -n 1 git worktree remove
----

--ghf-worktree-xargs::

	A convenience wrapper for piping 'ghf-worktree-list to the
	above man:xargs[1] command. Use it as e.g:
+
----
git hyperfine --ghf-worktree-xargs remove
----
+
Which will be the equivalent of the above command.

ALTERED OPTIONS[[ALTOPT]]
-------------------------

--help, --version::
	git-hyperfine's help and version output. The help output is
	the raw asciidoc of the installed man page.

--setup, --prepare, <command>::
	 Your '--setup' command (if any) will be chained behind the
	 setup command we'll use to setup the man:git-worktree[1].
+
All of these will be passed through as-is, except we'll add a thin
wrapper of 'cd <run-dir> && ...'.

-L, --parameter-list::
	Passed through as-is, except as a sanity check we'll die if
	you don't create a '-L rev ...' option. Our '--setup' option
	requires it to work.

-n, --command-name::
	You're not allowed to supply this anymore, as we'll need it to
	relabel our ugly generated 'cd <x> && ...' command name.

CONFIGURATION
-------------

This command can be configured through man:git-config[1], all the
options are in the 'hyperfine.*' namespace:

hyperfine.run-dir::

	Mandatory configuration which determines where to place the
	man:git-worktree[1] trees we create for resting the '{rev}'
	arguments.
+
Environment variables are supported, they're not understood by
man:git-config[1], but we'll shell 'eval()' this value.
+
A good setting would be:
+
----
[hyperfine]
run-dir = $XDG_RUNTIME_DIR/git-perf
----

See the 'git-hyperfine-gitconfig.cfg' file in the 'git-hyperfine'
repository for configuration examples. That's also available at
https://gitlab.com/avar/git-hyperfine/-/blob/master/git-hyperfine-gitconfig.cfg
and
https://github.com/avar/git-hyperfine/blob/master/git-hyperfine-gitconfig.cfg

EXAMPLES
--------

Test two revisions, and show that w we'll run in our worktree paths:

----
git hyperfine -L rev HEAD,HEAD~ -r 2 -s 'echo setup: $(pwd)' 'echo run: $(pwd)' -c 'echo cleanup: $(pwd)' -p 'echo prepare: $(pwd)' --show-output
----

DEPENDENCIES
------------

POSIX shell script. See <<COMPAT,COMPATIBILITY>> below.

To install documentation you'll need man:asciidoctor[1].

COMPATIBILITY[[COMPAT]]
-----------------------

'git-hyperfine' is written in in POSIX shellscript. It should be
compatible with Linux systems, BSDs, OSX, Solaris (not its /bin/sh
though), AIX, HP/UX etc. etc. Any incompatibility is a (probably small
and easily fixed) bug.

AUTHOR
------

Ævar Arnfjörð Bjarmason

INSTALLATION
------------

"git clone" the repository and add it to your '$PATH' for a quick
try-out (or don't add it to '$PATH' and provide the full path name).

For a proper installation there's an old-school GNU make 'Makefile' in
the top-level, to build and see what we'd install do:

----
make install INSTALL='@echo install'
----

And to install it for real drop the 'INSTALL' parameter, e.g.:

----
sudo make install prefix=/usr
----

To build and install documentation add 'install-man' to that (only the
latter target is needed). You can provide 'ASCIIDOCTOR' to be the path
to your 'asciidoctor' (or compatible) program.

---
make man
sudo make install-man prefix=/usr
---

HIPSTER INSTALLATION[[HIPSTER]]
-------------------------------

Like piping random code from the Internetz to man:sudo[1]? This one's
for you:

----
sudo bash -c "make prefix=$HOME/local HIPSTER=Y install install-man -f<(curl -s -o - https://gitlab.com/avar/git-hyperfine/-/raw/master/Makefile)"
----

It doesn't even require man:bash[1] (or man:sudo[1]), but if you like
to live dangerously.

BUGS
----

If man:hyperfine[1] introduces a new option 'git-hyperfine' currently
needs to be updated to know how to pass it through (its option usage
is somewhat irregular).


<<HIPSTER,HIPSTER INSTALLATION>> mode will cache the downloaded
program in the current working directory by virtue of being a
functioning 'Makefile' under the hood. It should probably download a
1GB tarball from somewhere instead to provide the full experience.

LICENSE
-------

'git-hyperfine' is triple-licensed under GPL v2.0 or later, MIT
License, and Apache License 2.0 or later.

I.e. a more than generous combination of the licenses of upstream
utilities it uses and extends. See
https://github.com/sharkdp/hyperfine/#license and
https://github.com/git/git/blob/master/COPYING

SEE ALSO
--------

man:hyperfine[1]
EOF
	exit 0
fi

## Configuration:
##
##	hyperfine.runtime-dir: eval'd; usually set to: $XDG_RUNTIME_DIR
run_dir=$(git config --get hyperfine.run-dir)
eval "run_dir=$run_dir"
debug "config: run-dir: <$run_dir>"

## We need to resolve the {rev} from the originating repository. Not
## our {run_dir}.
git_dir=$(git rev-parse --absolute-git-dir)

## --ghf-worktree-list
worktree_list () {
	# I can't remember how to do this with just sed(1), but you
	# can.
	git worktree list --porcelain --porcelain |
	grep "^worktree $run_dir" |
	sed 's/^worktree //'
}
if test -n "$worktree_list"
then
	worktree_list
	exit 0
fi

## --ghf-worktree-xargs
if test -n "$worktree_xargs"
then
	worktree_list | xargs -n 1 git worktree $@
	exit 0
fi

## --version output specific to git-hyperfine
if test -n "$version"
then
	echo git-hyperfine version whatever
	exit 0
fi

## Options sanity check
if test -z "$saw_rev"
then
	echo "git-hyperfine needs a -L rev <rev>..., e.g. -L rev HEAD~1,HEAD~0" >&2
	exit 1
fi

if test -n "$command_name"
then
	echo "$git-hyperfine can't take your -n|--command-name $command_name. It needs it" >&2
	exit 1
fi

## Templates for the command
## We're chain-invoking ourselves to get --setup etc. output below,
## this is to avoid some f the painful shell escaping
ghf_setup_template() {
	cat <<-\EOF |
	git_rev="$(git -C "{git_dir}" rev-parse {rev})" &&
	if ! test -d "{run_dir}/{rev}"
	then
		git worktree add "{run_dir}/{rev}" "{rev}";
	fi &&
	git -C "{run_dir}/{rev}" reset --hard $git_rev &&
	cd "{run_dir}/{rev}"
	EOF
	sed \
	    -e "s!{run_dir}!$run_dir!g" \
	    -e "s!{git_dir}!$git_dir!g"
}

## Debug utility
emit_dry_run() {
	printf "Would have invoke hyperfine(1) as:\n\n" >&2
	# TODO: Do something more clever
	printf "%s\n" $@
}

${dry_run:+emit_dry_run} \
hyperfine $hyperfine_opt \
	--setup " \
		${ghf_trace:+set -x;} \
		$(ghf_setup_template) \
		${setup:+ && $setup} \
	" \
	${prepare:+ --prepare "\
		${ghf_trace:+set -x;} \
		cd \"$run_dir/{rev}\" \
		${prepare:+ && $prepare} \
	"} \
	${cleanup:+ --cleanup "\
		${ghf_trace:+set -x;} \
		cd \"$run_dir/{rev}\" \
		${cleanup:+ && $cleanup} \
	"} \
	${command:+--command-name="$(tput setaf 6)$command$(tput sgr0)' in '$(tput setaf 6){rev}$(tput sgr0)"  \
	"\
		${ghf_trace:+set -x;} \
		cd \"$run_dir/{rev}\" &&
		$command \
	"}
